# CKB Time-lock Script Core Source Code Walkthrough (Official Implementation, Reorganized by Thought Process)

> This section introduces the official implementation principles and source code of the CKB time-lock script, suitable for developers with some Rust/CKB background. The script implements a lock mechanism based on block header timestamps, commonly used for scheduled unlocking, staking, and similar scenarios.

## Core Concepts

### Staking

Staking is an asset management mechanism in blockchain ecosystems, where users lock digital assets in smart contracts to earn network rewards, participate in governance, or secure the protocol. Common forms include:

- **Security Staking**: e.g., Ethereum 2.0, where validators must stake 32 ETH to participate in consensus, with penalties for malicious behavior to incentivize honesty and secure the network.
- **Governance Staking**: e.g., Compound, where holders stake COMP tokens to gain voting rights and participate in protocol parameter adjustments and asset listings.
- **Yield Staking**: e.g., ETH 2.0 validators earn block rewards and fee shares through staking, reflecting the economic incentives of staking.
- **Liquidity Management Staking**: Many DeFi protocols (like Curve, Convex) require users to lock tokens for a period to earn higher yields, using time locks to stabilize liquidity pools and reduce short-term arbitrage.

In the Nervos ecosystem, the Stable++ protocol is the first RGB++-based over-collateralized stablecoin system, using BTC and CKB as collateral assets. Users can stake these assets to mint RUSD, a USD-pegged stablecoin. Stable++ leverages RGB++'s cross-chain capabilities and CKB-VM's Turing completeness to build a secure, decentralized, and efficient staking and liquidation mechanism:

- Users can open staking positions, locking BTC or CKB as collateral. The system allows borrowing RUSD based on real-time collateral value, with the entire process executed by smart contracts to ensure immutability and asset security.
- The liquidation mechanism is also managed by contracts. When the collateral ratio falls below a safety threshold, anyone can trigger liquidation to maintain overall stability.
- This staking model not only brings new liquidity and use cases to the RGB++ ecosystem and Bitcoin assets but also provides users with a secure, transparent, and decentralized stablecoin lending and governance platform, promoting the growth of cross-chain DeFi.

### CKB Staking Principle: Script

On CKB, staking mechanisms are mainly implemented by writing **Scripts** for asset Cells. Lock Scripts implement asset locking via custom logic, only allowing unlocking when specific conditions (such as time, signature, multisig, etc.) are metâ€”suitable for fine-grained permission control. Type Scripts define asset types and transfer rules for more granular asset management, suitable for scenarios requiring asset-type management.

This section focuses on a common time-lock mechanism for staking: the contract **does not use CKB's Since/Locktime field**, but instead encodes the unlock timestamp in the lock script's arguments (lock args) and requires block headers in the transaction's `header_deps` field. The script iterates over these headers and checks if any header's timestamp meets or exceeds the unlock condition. Only when at least one header's timestamp is greater than or equal to the specified time limit can the asset be unlocked.

Additionally, since RGB++ enables isomorphic binding between CKB and BTC, BTC Time Lock can be implemented on CKB, verifying whether the timestamp on the BTC network meets the unlock condition when unlocking on CKB, thus enabling cross-chain time-lock mechanisms (covered in the next chapter).

---

## Step-by-step Implementation of ckb-script-time-lock

This section is based on the [ckb-script-time-lock](https://github.com/Hanssen0/ckb-script-time-lock) repository. All code snippets are from the official repo and include permanent links. Each line/section is followed by detailed English explanations to help you deeply understand every implementation detail.

### 1. Contract Entry and Main Flow

> [contracts/time_lock/src/main.rs#L6-L29](https://github.com/Hanssen0/ckb-script-time-lock/blob/master/contracts/time_lock/src/main.rs#L6-L29)

```rust
#![no_std]
#![no_main]
#![feature(lang_items)]
#![feature(alloc_error_handler)]
#![feature(panic_info_message)]

// define modules
mod entry;
mod error;

use ckb_std::default_alloc;

ckb_std::entry!(program_entry);
default_alloc!();

/// program entry
fn program_entry() -> i8 {
    // Call main function and return error code
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}
```

- This file is generated by the ckb-script-template tool, mainly for defining Rust language items and modules. The main logic is in entry.rs, and error types are in error.rs.
- `#![no_std]`: No standard library, suitable for blockchain bare-metal environments.
- The `ckb_std::entry!` macro defines the contract entry.
- `program_entry` is the contract's main entry, calling `entry::main()` and converting error types to i8 for CKB VM to recognize execution results.
  - The benefit of this design is that the main entry only outputs the final i8 result (0 for success, others for error codes), while error handling and return values are handled in `entry::main()`, which can use the Result type for flexible error handling and clearer, more maintainable code structure.

---

### 2. Dependency Imports and Argument Structure

#### 2.1 Dependency Imports

> [contracts/time_lock/src/entry.rs#L1-L15](https://github.com/Hanssen0/ckb-script-time-lock/blob/master/contracts/time_lock/src/entry.rs#L1-L15)

```rust
use core::result::Result;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::{bytes::Bytes, prelude::*},
    debug,
    dynamic_loading_c_impl::CKBDLContext,
    high_level::{load_header, load_script, QueryIter},
};
use crate::error::Error;
use ckb_lib_secp256k1::LibSecp256k1;
```

- Imports Rust's standard Result type for error handling.
- Imports common types and high-level APIs from ckb-std:
  - `Source`: Specifies data sources (HeaderDep, GroupInput, etc.).
  - `Bytes`, `prelude::*`: Byte handling and CKB type conversions.
  - `debug`: On-chain debug output.
  - `CKBDLContext`: Dynamically loads the secp256k1 C implementation.
  - `load_header`, `load_script`, `QueryIter`: High-level APIs for loading block headers, scripts, and iterating data.
- Imports the custom error type Error for unified error handling.
- Imports the main type LibSecp256k1 from the local secp256k1 library for signature verification and public key recovery.
  - Although LibSecp256k1 and its signature verification logic are the most common default lock on CKB, this contract demonstrates how to embed it as a module in custom lock scripts. Developers can reuse this signature verification process in their own custom lock logic (such as time locks, multisig, permission control, etc.), enabling more complex asset management and access control. This composability greatly enhances the flexibility and extensibility of CKB scripts.

#### 2.2 Parsing Lock Args and Calling Validation Flow in Main Function

> [contracts/time_lock/src/entry.rs#L16-L32](https://github.com/Hanssen0/ckb-script-time-lock/blob/master/contracts/time_lock/src/entry.rs#L16-L32)

```rust
pub fn main() -> Result<(), Error> {
    let script = load_script()?;
    let args: Bytes = script.args().unpack();

    if args.len() != 28 {
        return Err(Error::Encoding);
    }

    let pubkey = args.slice(0..20);
    let time_limit = args.slice(20..28);

    if !has_passed_time_limit(time_limit) {
        return Err(Error::TimeLimitNotReached);
    }

    // create a DL context with 128K buffer size
    let mut context = unsafe { CKBDLContext::<[u8; 128 * 1024]>::new() };
    let lib = LibSecp256k1::load(&mut context);

    test_validate_blake2b_sighash_all(&lib, &pubkey)
}
```

- The contract's main entry, returning Result<(), Error>, with all errors using the custom Error type.
- Parses the lock script arguments, which must be 28 bytes (20 bytes pubkey + 8 bytes timestamp).
- The first 20 bytes are the pubkey_hash, the last 8 bytes are the time_limit.
- Calls has_passed_time_limit to check if any block header in header_deps has a timestamp greater than or equal to time_limit.
- Creates a secp256k1 dynamic loading context and loads the local secp256k1 library.
- Calls test_validate_blake2b_sighash_all for signature verification.

---

## 3. Core Flow and Validation Logic

### 3.1 Time-lock Validation

> [contracts/time_lock/src/entry.rs#L34-L42](https://github.com/Hanssen0/ckb-script-time-lock/blob/master/contracts/time_lock/src/entry.rs#L34-L42)

```rust
fn has_passed_time_limit(time_limit: Bytes) -> bool {
    for header in QueryIter::new(load_header, Source::HeaderDep) {
        let timestamp = header.raw().timestamp().unpack().to_be_bytes();
        if time_limit.le(&timestamp) {
            return true;
        }
    }
    false
}
```

- Iterates over all header_deps and extracts the block header timestamps.
- If any block header's timestamp is greater than or equal to time_limit, returns true.
- Otherwise, returns false, indicating the unlock time has not been reached.

### 3.2 Signature Validation

> [contracts/time_lock/src/entry.rs#L44-L59](https://github.com/Hanssen0/ckb-script-time-lock/blob/master/contracts/time_lock/src/entry.rs#L44-L59)

```rust
fn test_validate_blake2b_sighash_all(
    lib: &LibSecp256k1,
    expected_pubkey_hash: &[u8],
) -> Result<(), Error> {
    let mut pubkey_hash = [0u8; 20];
    lib.validate_blake2b_sighash_all(&mut pubkey_hash)
        .map_err(|_err_code| {
            debug!("secp256k1 error {}", _err_code);
            Error::Secp256k1
        })?;

    // compare with expected pubkey_hash
    if &pubkey_hash[..] != expected_pubkey_hash {
        return Err(Error::WrongPubkey);
    }
    Ok(())
}
```

- Uses the secp256k1 library to verify the signature (validate_blake2b_sighash_all) and outputs debug information.
- After verification, compares the recovered pubkey_hash with the one in lock args.
- If they do not match, returns WrongPubkey error; otherwise, verification passes.

---

## 4. Error Handling and Type Definitions

### 4.1 Error Type Definition

> [contracts/time_lock/src/error.rs#L1-L11](https://github.com/Hanssen0/ckb-script-time-lock/blob/master/contracts/time_lock/src/error.rs#L1-L11)

```rust
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Secp256k1,
    WrongPubkey,
    TimeLimitNotReached,
}
```

- Defines possible error types for the contract, aiding debugging and issue localization.
- Each error type is assigned a unique i8 code for CKB VM recognition and debugging.
- Error types cover index out of bounds, item missing, insufficient length, encoding error, secp256k1 error, wrong pubkey, and time limit not reached.

### 4.2 Error Type Conversion

> [contracts/time_lock/src/error.rs#L13-L24](https://github.com/Hanssen0/ckb-script-time-lock/blob/master/contracts/time_lock/src/error.rs#L13-L24)

```rust
impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}
```

- Implements `From<SysError>` to unify system errors into custom error types.
- Maps different system errors to different custom errors; unknown errors trigger a panic.
- This allows the main flow to simply `return Err(Error::XXX)`, with the entry function converting to i8 for return.

---

## Summary

This section provides a detailed analysis of the design principles and source code structure of the official CKB time-lock script (ckb-script-time-lock). This contract encodes the unlock timestamp in the lock args and requires block headers to be provided in header_deps, verifying their timestamps to determine unlock eligibility. This achieves a flexible time-lock mechanism without relying on the Since field. The signature verification logic reuses the standard secp256k1_blake160_sighash_all process and is modularly embedded into the custom lock, greatly enhancing the composability and extensibility of scripts.

This design is not only suitable for common scenarios such as scheduled unlocking and staking, but also serves as a reference for developers to implement more advanced business logic like multisig, permission control, and cross-chain time locks. By flexibly combining the capabilities of CKB-VM and standard cryptographic libraries, developers can build secure, decentralized, and highly customizable asset management contracts, driving innovation and growth in the CKB ecosystem.

CKB's Cell/Script mechanism breaks through the limitations of traditional UTXO blockchains, which typically only support simple payments and multisig. By allowing each Cell to be bound to custom Lock and Type Scripts, developers can implement arbitrarily complex state validation and asset management logic. Combined with the Turing-completeness of CKB-VM, this model not only supports advanced features like time locks, permission control, and cross-chain verification, but also enables the implementation of complex contracts and decentralized applications similar to those on account-based blockchains. As a result, CKB stands out among UTXO blockchains as a platform with full on-chain programmability, providing a solid foundation for innovative DeFi, NFT, and cross-chain protocols.
